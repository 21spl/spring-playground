# Project Objectives

1. Overriding the default security configuration

2. Implementing `UserDetailsService` and a `PasswordEncoder`. 

3. These two components usually take part in authentication, and most applications customize them depending on their requirements. 

4. We will not make any custom implementation of UserDetailsService. We will use ```InMemoryUserDetailsManager```, which is an implementation provided by Spring Security

## Part 0: Create a HelloController to test security

```java
@RestController
public class HelloController {

    @GetMapping("/hello")
    public String sayHello() {
        return "Hello, World!";
    }

}
```


## Part 1: Configure UserDetailsService

1. Create a configuration class (say, SecurityConfig) annotated with @Configuration
2. Inside that class, create a Bean for ```UserDetailsService``` with @Bean annotation

```java
@Configuration
public class SecurityConfig{
    @Bean
    UserDetailsService userDetailsService(){
        return new InMemoryUserDetailsManager();
    }
}

```

3. The @Bean annotation instructs Spring to add the instance returned by the method to the spring context

4. If we execute the code, right now, we will no longer see the autogenerated password in the console

5. The application now uses instance of type UserDetailsService we added to the context instead of the default autoconfigured one

6. But at the same time, we won't be able to access the endpoint anymore because:
    - we don't have any users
    - we don't have any password encoder

7. Thus we need to:
    - create atleast one user who has a set of credentials (username and password)
    - Add the user to be managed by our implementation of UserDetailsService
    - Define a bean of type PasswordEncoder that our application can use to verify a given password with the one stored and managed by UserDetailsService

## Part 2: Creating a user with the User builder class for UserDetailsService

1. Here we declare and add a set of credentials that we can use for authentication to the instance of InMemoryUserDetailsManager

2. While building the instance, we must provide the username, password and atleast one authority.


```java
@Configuration
public class SecurityConfig{
    @Bean
    UserDetailsService userDetailsService(){

        // builds the user with a given username, password and authorities list
        UserDetails user = User.withUsername("wrik")
                            .password("12345")
                            .authorities("read")
                            .build();

        // add the user to InMemoryUserDetailsManager
        return new InMemoryUserDetailsManager(user);
    }
}

```

3. This modification is still not enough to allow us to call the endpoint. We haven't yet declared a `PasswordEncoder`

4. When using the default `UserDetailsService`, a `PasswordEncoder` is autoconfigured. But here we overrode `UserDetailsService`, so we have to declare a `PasswordEncoder`

5. Without declaring a PasswordEncoder, if we try to do the authentication,
```bash
curl -u wrik:12345 http://localhost:8080/hello
```
 Spring Security realizes it doesn't know how to manage the password and fails.

```bash
java.lang.IllegalArgumentException:
There is no PasswordEncoder mapped for the id "null"
at
org.springframework.security.crypto.
➥password.DelegatingPasswordEncoder$
➥UnmappedIdPasswordEncoder.matches(
➥DelegatingPasswordEncoder.java:289)
➥~[spring-security-crypto-6.0.0.jar:6.0.0]
at org.springframework.security.crypto.
➥password.DelegatingPasswordEncoder.matches(
➥DelegatingPasswordEncoder.java:237)
➥~[spring-security-crypto-6.0.0.jar:6.0.0]
```

Thus, we need to add a PasswordEncoder bean in the application context


## Part 3: Adding a PasswordEncoder
```java

@Bean
public PasswordEncoder passwordEncoder(){
    return new BcryptPasswordEncoder();
}

```

## Part 4: Hitting the endpoint

Finally the config class looks like:

```java
@Configuration
public class SecurityConfig{

    @Bean
    UserDetailsService userDetailsService(){
        // builds the user with a given username, password and authorities list
        UserDetails user = User.withUsername("wrik")
                            .password("12345")
                            .authorities("read")
                            .build();

        // add the user to InMemoryUserDetailsManager
        return new InMemoryUserDetailsManager(user);
    }

    @Bean
    public PasswordEncoder passwordEncoder(){
        return new BcryptPasswordEncoder();
    }
}

```

we can try the endpoint now with the username wrik and password 12345

```bash
curl -u wrik:12345 http://localhost:8080/hello
```


## Part 5: Writing test classes

1. By default spring boot provides Microproject2ApplicationTests.java class in the test package to test if the application context loads properly.
2. we leave it as it is and write the following test classes

#### 1. unit test for HelloController

```java
public class HelloControllerUnitTest {
    @Test
    void sayHelloReturnsMessage() {
        HelloController helloController = new HelloController();
        String response = helloController.sayHello();
        assertEquals("Hello, World!", response); // proper JUnit assertion
    }
}
```

- since this test doesn't require us to load the spring application context, we don't need to add the `@SpringBootTest` annotation.
- also we don't need to pass the endpoint path as request parameter
- we don't need to add the `@WebMvcTest` annotation.


#### Integration test for HelloController

```java
@SpringBootTest
@AutoConfigureMockMvc
public class HelloControllerIntegrationTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    void helloEndPointRequiresAuthentication() throws Exception {
        mockMvc.perform(get("/hello"))
               .andExpect(status().isUnauthorized());
    }

    @Test 
    void helloEndpointWithValidCredentials() throws Exception{
        mockMvc.perform(get("/hello")
               .with(httpBasic("wrik", "12345")))
               .andExpect(status().isOk())
               .andExpect(content().string("Hello, World!"));
    }

    @Test
    void helloEndpointWithInvalidUserFails() throws Exception {
        mockMvc.perform(get("/hello")
                .with(httpBasic("wrong", "password")))
                .andExpect(status().isUnauthorized());
    }

}
```

- this test requires us to load the spring application context, so we need to add the `@SpringBootTest` annotation
- we need to add the `@AutoConfigureMockMvc` annotation to create the `MockMvc` instance
- MockMvc is a testing framework provided by Spring to test web applications. It allows us to simulate HTTP requests and responses
- here we didn't add the `@WebMvcTest` annotation because @SpringBootTest loads the full Spring Boot application context (controllers, services, repositories, security, auto-configured beans)
- @WebMvcTest loads only Spring MVC components like controllers, filters, and Jackson; it does not load security beans or services unless you mock them. 
- mockMvc.perform() allows us to perform HTTP requests and assertions on the response
- mockMvc.perform(get("/hello")) sends a GET request to the /hello endpoint
- mockMvc.perform(get("/hello").with(httpBasic("wrik", "12345"))) sends a GET request to the /hello endpoint with basic authentication headers


#### Integration test for UserDetailsService

```java
@SpringBootTest
public class UserDetailsServiceTest {

    @Autowired
    private UserDetailsService userDetailsService;

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Test
    void testLoadUserByUsername(){
        UserDetails userdetails = userDetailsService.loadUserByUsername("wrik");
        assertEquals("wrik", userdetails.getUsername());
        assertTrue(passwordEncoder.matches("12345", userdetails.getPassword()));
        assertTrue(userdetails.getAuthorities().stream()
                   .anyMatch(auth -> auth.getAuthority().equals("read")));
    }

}
```

- this test also requires us to load the spring application context, so we need to add the `@SpringBootTest` annotation
- `userDetailsService.loadUserByUsername("wrik")` loads the user with the given username from the UserDetailsService
- `passwordEncoder.matches("12345", userdetails.getPassword())` checks if the password matches the encoded password
- `userdetails.getAuthorities().stream().anyMatch(auth -> auth.getAuthority().equals("read"))` checks if the user has the "read" authority